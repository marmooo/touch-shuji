const w1_ = Array.from(
  "一右雨円王音下火花貝学気九休玉金空月犬見五口校左三山子四糸字耳七車手十出女小上森人水正生青夕石赤千川先早草足村大男竹中虫町天田土二日入年白八百文木本名目立力林六",
);
const w2_ = Array.from(
  "引羽雲園遠何科夏家歌画回会海絵外角楽活間丸岩顔汽記帰弓牛魚京強教近兄形計元言原戸古午後語工公広交光考行高黄合谷国黒今才細作算止市矢姉思紙寺自時室社弱首秋週春書少場色食心新親図数西声星晴切雪船線前組走多太体台地池知茶昼長鳥朝直通弟店点電刀冬当東答頭同道読内南肉馬売買麦半番父風分聞米歩母方北毎妹万明鳴毛門夜野友用曜来里理話",
);
const w3_ = Array.from(
  "悪安暗医委意育員院飲運泳駅央横屋温化荷界開階寒感漢館岸起期客究急級宮球去橋業曲局銀区苦具君係軽血決研県庫湖向幸港号根祭皿仕死使始指歯詩次事持式実写者主守取酒受州拾終習集住重宿所暑助昭消商章勝乗植申身神真深進世整昔全相送想息速族他打対待代第題炭短談着注柱丁帳調追定庭笛鉄転都度投豆島湯登等動童農波配倍箱畑発反坂板皮悲美鼻筆氷表秒病品負部服福物平返勉放味命面問役薬由油有遊予羊洋葉陽様落流旅両緑礼列練路和",
);
const w4_ = Array.from(
  "愛案以衣位茨印英栄媛塩岡億加果貨課芽賀改械害街各覚潟完官管関観願岐希季旗器機議求泣給挙漁共協鏡競極熊訓軍郡群径景芸欠結建健験固功好香候康佐差菜最埼材崎昨札刷察参産散残氏司試児治滋辞鹿失借種周祝順初松笑唱焼照城縄臣信井成省清静席積折節説浅戦選然争倉巣束側続卒孫帯隊達単置仲沖兆低底的典伝徒努灯働特徳栃奈梨熱念敗梅博阪飯飛必票標不夫付府阜富副兵別辺変便包法望牧末満未民無約勇要養浴利陸良料量輪類令冷例連老労録",
);
const w5_ = Array.from(
  "圧囲移因永営衛易益液演応往桜可仮価河過快解格確額刊幹慣眼紀基寄規喜技義逆久旧救居許境均禁句型経潔件険検限現減故個護効厚耕航鉱構興講告混査再災妻採際在財罪殺雑酸賛士支史志枝師資飼示似識質舎謝授修述術準序招証象賞条状常情織職制性政勢精製税責績接設絶祖素総造像増則測属率損貸態団断築貯張停提程適統堂銅導得毒独任燃能破犯判版比肥非費備評貧布婦武復複仏粉編弁保墓報豊防貿暴脈務夢迷綿輸余容略留領歴",
);
const w6_ = Array.from(
  "胃異遺域宇映延沿恩我灰拡革閣割株干巻看簡危机揮貴疑吸供胸郷勤筋系敬警劇激穴券絹権憲源厳己呼誤后孝皇紅降鋼刻穀骨困砂座済裁策冊蚕至私姿視詞誌磁射捨尺若樹収宗就衆従縦縮熟純処署諸除承将傷障蒸針仁垂推寸盛聖誠舌宣専泉洗染銭善奏窓創装層操蔵臓存尊退宅担探誕段暖値宙忠著庁頂腸潮賃痛敵展討党糖届難乳認納脳派拝背肺俳班晩否批秘俵腹奮並陛閉片補暮宝訪亡忘棒枚幕密盟模訳郵優預幼欲翌乱卵覧裏律臨朗論",
);
// https://okjiten.jp/7-tyuugakuseikanji.html
// 漢検4級
const w7_ = Array.from(
  "握扱依威偉為違緯維壱芋隠陰鋭影越援縁煙鉛汚押奥憶菓箇暇雅介壊戒皆較獲刈甘監汗歓勧乾鑑環含奇鬼祈輝幾儀戯詰脚却丘及朽拠巨距御驚凶恐響叫狭狂況仰駆屈掘繰傾恵迎撃肩堅遣兼軒圏剣玄誇鼓枯継互更荒抗攻稿香恒項豪込婚鎖歳彩載剤咲惨雌伺紫刺脂旨執芝煮斜釈寂狩朱趣需秀舟襲柔獣瞬巡旬盾紹召沼詳床称畳丈飾殖触浸震慎侵寝振薪陣尽尋吹是征姓井跡扇占鮮訴燥騒僧贈即俗耐替拓沢濁脱丹端嘆淡弾恥遅致蓄沖跳徴澄珍沈抵堤摘滴添殿途吐渡奴怒透唐桃盗塔到倒逃踏稲闘胴峠突鈍曇弐悩濃輩杯泊拍迫薄爆髪抜罰繁販搬範般盤被疲彼避尾微匹描浜敏怖膚浮腐敷普賦舞幅払噴柄壁捕舗峰抱砲肪坊忙冒傍帽凡盆漫慢妙眠矛霧娘茂網猛黙紋踊雄与誉腰溶躍謡翼雷頼絡欄離粒慮療隣涙隷麗齢暦劣烈恋露郎惑腕",
);
// 漢検3級
const w8_ = Array.from(
  "哀慰詠悦閲炎宴欧殴乙卸穏架佳華嫁餓怪悔塊概慨該穫隔郭岳掛滑勘肝貫敢緩冠換喚企軌棄棋忌既岐騎犠欺菊吉喫虐虚脅峡凝緊斤愚偶遇啓鶏携掲刑憩契鯨賢倹幻雇顧弧孤悟娯甲孔控拘郊硬綱巧坑慌絞酵克獄魂紺恨墾催債削錯搾撮擦暫施祉諮侍慈軸湿疾赦邪殊寿潤遵徐如晶掌鐘焦衝昇匠譲錠嬢冗嘱辱審伸辛粋炊遂衰穂酔随髄瀬牲婿請隻惜斥籍摂潜繕措阻粗礎双桑葬掃遭憎促賊逮胎怠滞袋滝託卓択諾奪胆鍛壇稚畜窒駐抽鋳彫超聴陳鎮墜訂帝締哲斗塗陶凍痘匿篤豚尿粘婆排陪縛伐帆伴藩畔蛮泌卑碑姫漂苗赴符封伏覆墳紛癖募慕簿崩芳胞縫倣邦飽奉妨乏謀膨房某墨没翻魔埋膜又魅滅免幽憂誘擁揚揺抑裸濫吏隆了猟陵糧厘零霊励裂錬廉炉漏廊浪楼湾",
);
const w9_ = Array.from(
  "亜尉逸姻韻畝浦疫謁猿凹翁虞渦禍靴寡稼蚊拐懐劾涯垣核殻嚇潟括喝渇褐轄且缶陥患堪棺款閑寛憾還艦頑飢宜偽擬糾窮拒享挟恭矯暁菌琴謹襟吟隅勲薫茎渓蛍慶傑嫌献謙繭顕懸弦呉碁江肯侯洪貢溝衡購拷剛酷昆懇佐唆詐砕宰栽斎崎索酢桟傘肢嗣賜滋璽漆遮蛇酌爵珠儒囚臭愁酬醜汁充渋銃叔淑粛塾俊准殉循庶緒叙升抄肖尚宵症祥渉訟硝粧詔奨彰償礁浄剰縄壌醸津唇娠紳診刃迅甚帥睡枢崇据杉斉逝誓析拙窃仙栓旋践遷薦繊禅漸租疎塑壮荘捜挿曹喪槽霜藻妥堕惰駄泰濯但棚痴逐秩嫡衷弔挑眺釣懲勅朕塚漬坪呈廷邸亭貞逓偵艇泥迭徹撤悼搭棟筒謄騰洞督凸屯軟尼妊忍寧把覇廃培媒賠伯舶漠肌鉢閥煩頒妃披扉罷猫賓頻瓶扶附譜侮沸雰憤丙併塀幣弊偏遍泡俸褒剖紡朴僕撲堀奔麻摩磨抹岬銘妄盲耗厄愉諭癒唯悠猶裕融庸窯羅酪痢履柳竜硫虜涼僚寮倫累塁戻鈴賄枠挨曖宛嵐畏萎椅彙茨咽淫唄鬱怨媛艶旺岡臆俺苛牙瓦楷潰諧崖蓋骸柿顎葛釜鎌韓玩伎亀毀畿臼嗅巾僅錦惧串窟熊詣憬稽隙桁拳鍵舷股虎錮勾梗喉乞傲駒頃痕沙挫采塞埼柵刹拶斬恣摯餌鹿叱嫉腫呪袖羞蹴憧拭尻芯腎須裾凄醒脊戚煎羨腺詮箋膳狙遡曽爽痩踪捉遜汰唾堆戴誰旦綻緻酎貼嘲捗椎爪鶴諦溺填妬賭藤瞳栃頓貪丼那奈梨謎鍋匂虹捻罵剥箸氾汎阪斑眉膝肘阜訃蔽餅璧蔑哺蜂貌頬睦勃昧枕蜜冥麺冶弥闇喩湧妖瘍沃拉辣藍璃慄侶瞭瑠呂賂弄籠麓脇",
);
const gradeByKanjis = [w1_, w1_, w2_, w3_, w4_, w5_, w6_, w7_, w8_, w9_];
const dirNames = [
  "小1",
  "小1",
  "小2",
  "小3",
  "小4",
  "小5",
  "小6",
  "中2",
  "中3",
  "常用",
  "常用外",
];
let prevCanvasSize;
let canvasSize = 140;
let maxWidth = 4;
if (window.innerWidth > 768) {
  canvasSize = 280;
  maxWidth = 8;
}
let correctAudio, incorrectAudio, correctAllAudio, stupidAudio;
loadAudios();
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioContext();
const animCJKDir = "/animCJK";
let kanjis = "";
let level = 2;
loadConfig();

// function toKanji(kanjiId) {
//   return String.fromCodePoint(parseInt("0x" + kanjiId));
// }

// function fetchKanjiSVG(kanji, kanjiId) {
//   return new Promise((resolve) => {
//     fetch(
//       animCJKDir + "/" + getKanjiDir(kanji, kanjiId) + "/" + kanjiId + ".svg",
//     )
//       .then((response) => response.text())
//       .then((text) => {
//         const parser = new DOMParser();
//         return parser.parseFromString(text, "text/html");
//       }).then((html) => {
//         const kanji = html.getElementsByTagName("svg")[0];
//         kanji.setAttribute("width", canvasSize);
//         kanji.setAttribute("height", canvasSize);
//         kanji.removeAttribute("id");
//         resolve(html);
//       });
//   });
// }

function getGrade(str) {
  for (let grade = 1; grade < gradeByKanjis.length; grade++) {
    if (gradeByKanjis[grade].includes(str)) {
      return grade;
    }
  }
  if (/[\u4E00-\u9FFF]/.test(str)) {
    return 10;
  } else {
    return -1;
  }
}

function getDictUrl(kanji) {
  const baseUrl = "https://marmooo.github.io";
  const grade = getGrade(kanji);
  if (grade < 0) {
    return null;
  } else if (grade == 10) {
    return baseUrl + "/kanji-dict/常用外/" + kanji + "/";
  } else {
    return baseUrl + "/kanji-dict/" + dirNames[grade] + "/" + kanji + "/";
  }
}

function loadConfig() {
  if (localStorage.getItem("darkMode") == 1) {
    document.documentElement.dataset.theme = "dark";
  }
  if (localStorage.getItem("hint") == 1) {
    document.getElementById("hint").textContent = "EASY";
  }
  if (localStorage.getItem("touch-shuji-level")) {
    level = parseInt(localStorage.getItem("touch-shuji-level"));
  }
}

function toggleDarkMode() {
  if (localStorage.getItem("darkMode") == 1) {
    localStorage.setItem("darkMode", 0);
    delete document.documentElement.dataset.theme;
  } else {
    localStorage.setItem("darkMode", 1);
    document.documentElement.dataset.theme = "dark";
  }
}

function toggleHint() {
  if (localStorage.getItem("hint") == 1) {
    localStorage.setItem("hint", 0);
    this.textContent = "HARD";
  } else {
    localStorage.setItem("hint", 1);
    this.textContent = "EASY";
  }
  toggleAllStroke();
}

function toggleScroll() {
  const scrollable = document.getElementById("scrollable");
  const pinned = document.getElementById("pinned");
  if (scrollable.classList.contains("d-none")) {
    window.removeEventListener("touchstart", scrollEvent, { passive: false });
    window.removeEventListener("touchmove", scrollEvent, { passive: false });
    scrollable.classList.remove("d-none");
    pinned.classList.add("d-none");
  } else {
    window.addEventListener("touchstart", scrollEvent, { passive: false });
    window.addEventListener("touchmove", scrollEvent, { passive: false });
    scrollable.classList.add("d-none");
    pinned.classList.remove("d-none");
  }
}

function playAudio(audioBuffer, volume) {
  const audioSource = audioContext.createBufferSource();
  audioSource.buffer = audioBuffer;
  if (volume) {
    const gainNode = audioContext.createGain();
    gainNode.gain.value = volume;
    gainNode.connect(audioContext.destination);
    audioSource.connect(gainNode);
    audioSource.start();
  } else {
    audioSource.connect(audioContext.destination);
    audioSource.start();
  }
}

function unlockAudio() {
  audioContext.resume();
}

function loadAudio(url) {
  return fetch(url)
    .then((response) => response.arrayBuffer())
    .then((arrayBuffer) => {
      return new Promise((resolve, reject) => {
        audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
          resolve(audioBuffer);
        }, (err) => {
          reject(err);
        });
      });
    });
}

function loadAudios() {
  promises = [
    loadAudio("/touch-shuji/mp3/correct3.mp3"),
    loadAudio("/touch-shuji/mp3/incorrect1.mp3"),
    loadAudio("/touch-shuji/mp3/correct1.mp3"),
    loadAudio("/touch-shuji/mp3/stupid5.mp3"),
  ];
  Promise.all(promises).then((audioBuffers) => {
    correctAudio = audioBuffers[0];
    incorrectAudio = audioBuffers[1];
    correctAllAudio = audioBuffers[2];
    stupidAudio = audioBuffers[3];
  });
}

customElements.define(
  "problem-box",
  class extends HTMLElement {
    constructor() {
      super();
      const template = document.getElementById("problem-box").content.cloneNode(
        true,
      );
      this.attachShadow({ mode: "open" }).appendChild(template);
    }
  },
);
customElements.define(
  "tehon-box",
  class extends HTMLElement {
    constructor() {
      super();
      const template = document.getElementById("tehon-box").content.cloneNode(
        true,
      );
      this.attachShadow({ mode: "open" }).appendChild(template);
    }
  },
);
customElements.define(
  "tegaki-box",
  class extends HTMLElement {
    constructor() {
      super();
      const template = document.getElementById("tegaki-box").content.cloneNode(
        true,
      );
      if (window.innerWidth > 768) {
        const canvas = template.querySelector("canvas");
        canvas.setAttribute("width", canvasSize);
        canvas.setAttribute("height", canvasSize);
      }
      this.attachShadow({ mode: "open" }).appendChild(template);
    }
  },
);

function getKakusu(object, kanjiId) {
  const id = "z" + kanjiId + "d";
  const paths = object.contentDocument.querySelectorAll('[id^="' + id + '"]');
  const ids = [...paths].map((path) => path.getAttribute("id"));
  const kakuIds = ids.map((id) => {
    if (/[a-z]/.test(id.slice(-1))) {
      return id.slice(0, -1);
    } else {
      return id;
    }
  });
  return uniq(kakuIds).length;
}

const alphabets = "abcefghijklmnopqrstuvwxyz".split("");
function getKakuPaths(contentDocument, kanjiId, pos) {
  const id = "z" + kanjiId + "d" + pos;
  const paths = contentDocument.querySelectorAll('[id="' + id + '"]');
  if (paths.length != 0) {
    return [...paths];
  } else {
    const paths = [];
    for (let i = 0; i < alphabets.length; i++) {
      const path = contentDocument.querySelectorAll(
        '[id="' + id + alphabets[i] + '"]',
      );
      paths.push(...path);
    }
    return paths;
  }
}

function getTehonCanvas(object, kanjiId, kakusu, kakuNo) {
  return new Promise(function (resolve) {
    const clonedContent = object.contentDocument.cloneNode(true);
    for (let j = 1; j <= kakusu; j++) {
      const kakuPaths = getKakuPaths(clonedContent, kanjiId, j);
      if (kakuNo != j) {
        kakuPaths.forEach((kakuPath) => kakuPath.remove());
      } else {
        kakuPaths.forEach((kakuPath) => {
          kakuPath.setAttribute("stroke", "black");
        });
      }
    }
    const text = clonedContent.documentElement.outerHTML;
    const blob = new Blob([text], { type: "image/svg+xml" });
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.src = url;
    img.onload = function () {
      const canvas = document.createElement("canvas");
      canvas.width = canvasSize;
      canvas.height = canvasSize;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, canvasSize, canvasSize);
      resolve(canvas);
    };
  });
}

const specials = [
  "20043",
  "21450",
  "27665",
  "29995",
  "30001",
  "30002",
  "30003",
  "30011",
  "31899",
  "37325",
  "37340",
];
function getKanjiDir(kanji, kanjiId) {
  if (/[ぁ-んァ-ヶ]/.test(kanji)) {
    return "svgsKana";
  } else {
    if (specials.includes(kanjiId)) {
      return "svgsJaSpecial";
    } else {
      return "svgsJa";
    }
  }
}

function toKanjiId(str) {
  const oct = str.codePointAt(0).toString(10);
  return ("00000" + oct).slice(-5);
}

function loadSVG(kanji, kanjiId, parentNode, pos, loadCanvas) {
  let box;
  if (loadCanvas) {
    box = document.createElement("tegaki-box");
  } else {
    box = document.createElement("tehon-box");
  }
  const object = box.shadowRoot.querySelector("object");
  object.setAttribute("alt", kanji);
  object.setAttribute(
    "data",
    animCJKDir + "/" + getKanjiDir(kanji, kanjiId) + "/" + kanjiId + ".svg",
  );
  object.setAttribute("data-id", kanjiId);
  object.setAttribute("data-pos", pos);
  if (loadCanvas) {
    object.setAttribute("onload", "_initTegakiSVG(this)");
  } else {
    object.setAttribute("onload", "_initTehonSVG(this)");
  }
  parentNode.appendChild(box);
  return object;
}

function showKanjiScore(
  kanjiScore,
  kakuScores,
  scoreObj,
  tehonKanji,
  object,
  kanjiId,
  kakusu,
) {
  kanjiScore = Math.floor(kanjiScore);
  if (kanjiScore >= 80) {
    playAudio(correctAudio);
  } else {
    playAudio(incorrectAudio);
  }
  scoreObj.classList.remove("d-none");
  scoreObj.textContent = kanjiScore;
  for (let i = 0; i < kakusu; i++) {
    changePathColor(i + 1, tehonKanji, kanjiId, "black");
  }
  for (let i = 0; i < kakusu; i++) {
    if (!kakuScores[i][0] || kakuScores[i][0] < 80) {
      changePathColor(i + 1, tehonKanji, kanjiId, "red");
    }
  }
  if (localStorage.getItem("hint") != 1) {
    changeAllColor(object, kanjiId, "lightgray");
  }
}

function getKanjiScores(
  kakuScores,
  scoreObj,
  tehonKanji,
  object,
  kanjiId,
  kakusu,
) {
  return Promise.all(kakuScores).then((kakuScores) => {
    let kanjiScore = 0;
    let totalTehonCount = 0;
    kakuScores.forEach((kakuData) => {
      const [kakuScore, tehonCount] = kakuData;
      kanjiScore += kakuScore * tehonCount;
      totalTehonCount += tehonCount;
    });
    kanjiScore /= totalTehonCount;
    showKanjiScore(
      kanjiScore,
      kakuScores,
      scoreObj,
      tehonKanji,
      object,
      kanjiId,
      kakusu,
    );
    return kanjiScore;
  });
}

function getProblemScores(tegakiPanel, tehonPanel, objects, tegakiPads) {
  const promises = [];
  objects.forEach((object, i) => {
    const kanjiId = object.dataset.id;
    const kakusu = getKakusu(object, kanjiId);
    const pos = parseInt(object.dataset.pos);
    const tegakiData = tegakiPads[i].toData();
    let kanjiScores = 0;
    if (tegakiData.length != 0) {
      const tehonKanji = tehonPanel.children[pos].shadowRoot.querySelector(
        "object",
      );
      const scoreObj = tegakiPanel.children[pos].shadowRoot.querySelector(
        "#score",
      );
      const kakuScores = getKakuScores(tegakiData, object, kanjiId, kakusu);
      kanjiScores = getKanjiScores(
        kakuScores,
        scoreObj,
        tehonKanji,
        object,
        kanjiId,
        kakusu,
      );
    }
    promises[i] = kanjiScores;
  });
  return Promise.all(promises);
}

function setScoringButton(
  problemBox,
  tegakiPanel,
  tehonPanel,
  objects,
  tegakiPads,
  word,
) {
  const scoring = problemBox.shadowRoot.querySelector("#scoring");
  scoring.addEventListener("click", function () {
    getProblemScores(tegakiPanel, tehonPanel, objects, tegakiPads).then(
      (scores) => {
        if (scores.every((score) => score >= 80)) {
          problemBox.shadowRoot.querySelector("#guard").style.height = "100%";
          const next = problemBox.nextElementSibling;
          if (next) {
            next.shadowRoot.querySelector("#guard").style.height = "0";
            const headerHeight = document.getElementById("header").offsetHeight;
            const top = next.getBoundingClientRect().top +
              document.documentElement.scrollTop - headerHeight;
            window.scrollTo({ top: top, behavior: "smooth" });
          } else {
            window.removeEventListener("touchstart", scrollEvent, {
              passive: false,
            });
            window.removeEventListener("touchmove", scrollEvent, {
              passive: false,
            });
          }
        }
        // 点数があまりにも低いものは合格リストから除外
        let clearedKanjis = localStorage.getItem("touch-shuji");
        if (clearedKanjis) {
          let removed = false;
          scores.forEach((score, i) => {
            if (score < 40) {
              clearedKanjis = clearedKanjis.replace(word[i], "");
              removed = true;
            }
          });
          if (removed) {
            localStorage.setItem("touch-shuji", clearedKanjis);
          }
        }
      },
    );
  });
}

function setSignaturePad(object) {
  const canvas = object.parentNode.querySelector("canvas");
  const pad = new SignaturePad(canvas, {
    minWidth: 0.1,
    maxWidth: maxWidth,
    penColor: "black",
    throttle: 0,
    minDistance: 0,
    velocityFilterWeight: 0,
  });
  return pad;
}

function setEraser(tegakiPad, tegakiPanel, tehonPanel, object, kanjiId) {
  const currKanji = object.getRootNode().host;
  const kanjiPos = [...tegakiPanel.children].findIndex((x) => x == currKanji);
  tehonPanel.children[kanjiPos].shadowRoot.querySelector("#eraser").onclick =
    function () {
      const data = tegakiPad.toData();
      if (data) {
        tegakiPad.clear();
      }
      const pos = parseInt(object.dataset.pos);
      const scoreObj = tegakiPanel.children[pos].shadowRoot.querySelector(
        "#score",
      );
      scoreObj.classList.add("d-none");
      if (localStorage.getItem("hint") != 1) {
        changeAllColor(object, kanjiId, "none");
      }
    };
}

function setDict(tehonPanel, object, kanji) {
  const pos = parseInt(object.dataset.pos);
  const dict = tehonPanel.children[pos].shadowRoot.querySelector("#dict");
  const url = getDictUrl(kanji);
  if (url) {
    dict.href = url;
  } else {
    dict.classList.add("d-none");
  }
}

function loadProblem(wordYomi) {
  const [word, yomi] = wordYomi.split("|");
  const problemBox = document.createElement("problem-box");
  const shadow = problemBox.shadowRoot;
  const info = shadow.querySelector("#info");
  info.textContent = yomi;
  const search = shadow.querySelector("#search");
  search.href = "https://www.google.com/search?q=" + word + "とは";
  const objects = [];
  const tegakiPads = [];
  const tehon = shadow.querySelector("#tehon");
  const tegaki = shadow.querySelector("#tegaki");
  word.split("").forEach((kanji, pos) => {
    const kanjiId = toKanjiId(kanji);
    loadSVG(kanji, kanjiId, tehon, pos, false);
    const object = loadSVG(kanji, kanjiId, tegaki, pos, true);
    const tegakiPad = setSignaturePad(object);
    objects.push(object);
    tegakiPads.push(tegakiPad);
    setEraser(tegakiPad, tegaki, tehon, object, kanjiId);
    setDict(tehon, object, kanji);
  });
  setScoringButton(problemBox, tegaki, tehon, objects, tegakiPads, word);
  document.getElementById("problems").appendChild(problemBox);
  return tegakiPads;
}

function resizeTegakiContents(tegakiPads) {
  tegakiPads.forEach((tegakiPad) => {
    const canvas = tegakiPad.canvas;
    canvas.setAttribute("width", canvasSize);
    canvas.setAttribute("height", canvasSize);
    const data = tegakiPad.toData();
    if (data.length > 0) {
      tegakiPad.maxWidth = maxWidth;
      if (prevCanvasSize < canvasSize) {
        for (let i = 0; i < data.length; i++) {
          for (let j = 0; j < data[i].length; j++) {
            data[i][j].x /= 2;
            data[i][j].y /= 2;
          }
        }
      } else {
        for (let i = 0; i < data.length; i++) {
          for (let j = 0; j < data[i].length; j++) {
            data[i][j].x /= 2;
            data[i][j].y /= 2;
          }
        }
      }
      tegakiPad.fromData(data);
    }
  });
}

function loadDrill(drill) {
  let tegakiPads = [];
  drill.forEach((wordYomi) => {
    const pads = loadProblem(wordYomi);
    tegakiPads = tegakiPads.concat(pads);
  });
  window.onresize = function () {
    prevCanvasSize = canvasSize;
    if (window.innerWidth >= 768) {
      canvasSize = 280;
      maxWidth = 8;
    } else {
      canvasSize = 140;
      maxWidth = 4;
    }
    if (prevCanvasSize != canvasSize) {
      resizeTegakiContents(tegakiPads);
    }
  };
}

// 器用差の大きい低学年の採点が緩くなるよう太さを変える
function setStrokeWidth(kakusu) {
  if (window.innerWidth > 768) {
    return 20 + 12 / kakusu;
  } else {
    return 10 + 6 / kakusu;
  }
}

function toggleAllStroke() {
  const problems = document.getElementById("problems").children;
  for (const problem of problems) {
    const tegakiBoxes = problem.shadowRoot.querySelector("#tegaki").children;
    for (const tegakiBox of tegakiBoxes) {
      const object = tegakiBox.shadowRoot.querySelector("object");
      const kanjiId = object.dataset.id;
      toggleStroke(object, kanjiId);
    }
  }
}

function toggleStroke(object, kanjiId) {
  const id = "z" + kanjiId + "d";
  const paths = object.contentDocument.querySelectorAll('[id^="' + id + '"]');
  const width = 128;
  [...paths].forEach((path) => {
    if (localStorage.getItem("hint") != 1) {
      path.style.fill = "none";
      path.setAttribute("stroke", "none");
    } else {
      path.style.fill = "lightgray";
      path.setAttribute("stroke", "lightgray");
    }
    path.setAttribute("stroke-width", width);
  });
}

function changeAllColor(object, kanjiId, color) {
  const id = "z" + kanjiId + "d";
  const paths = object.contentDocument.querySelectorAll('[id^="' + id + '"]');
  [...paths].forEach((path) => {
    path.style.fill = color;
  });
}

function changePathColor(pos, object, kanjiId, color) {
  removeAnimations(object);
  const paths = getKakuPaths(object.contentDocument, kanjiId, pos);
  paths.forEach((path) => {
    path.style.fill = color;
  });
}

function countNoTransparent(data) {
  let count = 0;
  for (let i = 3; i < data.length; i += 4) {
    if (data[i] != 0) {
      count += 1;
    }
  }
  return count;
}

function getInclusionCount(tegakiImgData, tehonImgData) {
  for (let i = 3; i < tegakiImgData.length; i += 4) {
    if (tehonImgData[i] != 0) {
      tegakiImgData[i] = 0;
    }
  }
  const inclusionCount = countNoTransparent(tegakiImgData);
  return inclusionCount;
}

function getScoringFactor(level) {
  console.log(level);
  switch (level) {
    case 0:
      return 0.5 ** 2;
    case 1:
      return 0.6 ** 2;
    case 2:
      return 0.7 ** 2;
    case 3:
      return 0.8 ** 2;
    case 4:
      return 0.9 ** 2;
    default:
      return 0.7 ** 2;
  }
}

function calcKakuScore(tegakiCount, tehonCount, inclusionCount) {
  // 線長を優遇し過ぎると ["未","末"], ["土","士"] の見分けができなくなる
  let lineScore = (1 - Math.abs((tehonCount - tegakiCount) / tehonCount));
  if (lineScore > 1) lineScore = 1;
  // 包含率を優遇し過ぎると ["一","つ"], ["二","＝"] の見分けができなくなる
  let inclusionScore = (tegakiCount - inclusionCount) / tegakiCount;
  if (inclusionScore > 1) inclusionScore = 1;
  // 100点が取れないので少しだけ採点を甘くする
  let kakuScore = lineScore * inclusionScore * 100 / getScoringFactor(level);
  if (kakuScore < 0) kakuScore = 0;
  if (kakuScore > 100) kakuScore = 100;
  if (isNaN(kakuScore)) kakuScore = 0;
  return kakuScore;
}

function getKakuScores(tegakiData, object, kanjiId, kakusu) {
  const markerWidth = setStrokeWidth(kakusu);
  const promises = new Array(kakusu);
  for (let i = 0; i < kakusu; i++) {
    promises[i] = new Promise((resolve) => {
      if (tegakiData[i]) {
        tegakiData[i].minWidth = markerWidth;
        tegakiData[i].maxWidth = markerWidth;
        const markerCanvas = document.createElement("canvas");
        markerCanvas.setAttribute("width", canvasSize);
        markerCanvas.setAttribute("height", canvasSize);
        const markerContext = markerCanvas.getContext("2d");
        const markerPad = new SignaturePad(markerCanvas, {
          minWidth: markerWidth,
          maxWidth: markerWidth,
          penColor: "black",
        });
        markerPad.fromData([tegakiData[i]]);
        const kakuData =
          markerContext.getImageData(0, 0, canvasSize, canvasSize).data;
        const kakuCount = countNoTransparent(kakuData);
        getTehonCanvas(object, kanjiId, kakusu, i + 1).then((tehonCanvas) => {
          const tehonImgData = tehonCanvas.getContext("2d").getImageData(
            0,
            0,
            canvasSize,
            canvasSize,
          ).data;
          const tehonCount = countNoTransparent(tehonImgData);

          const inclusionCount = getInclusionCount(kakuData, tehonImgData);
          const kakuScore = calcKakuScore(
            kakuCount,
            tehonCount,
            inclusionCount,
          );
          resolve([kakuScore, tehonCount]);
        });
      } else {
        getTehonCanvas(object, kanjiId, kakusu, i + 1).then((tehonCanvas) => {
          const tehonImgData = tehonCanvas.getContext("2d").getImageData(
            0,
            0,
            canvasSize,
            canvasSize,
          ).data;
          const tehonCount = countNoTransparent(tehonImgData);
          resolve([0, tehonCount]);
        });
      }
    });
  }
  return promises;
}

function removeAnimations(object) {
  const animations = object.contentDocument.querySelectorAll("path[clip-path]");
  [...animations].forEach((animation) => {
    animation.remove();
  });
}

function _initTegakiSVG(object) {
  const kanjiId = object.dataset.id;
  removeAnimations(object);
  toggleStroke(object, kanjiId);
}

function _initTehonSVG(_object) {
}

function report() {
  const scores = [];
  const problems = document.getElementById("problems").children;
  for (let i = 0; i < problems.length; i++) {
    const tegakis = problems[i].shadowRoot.querySelector("#tegaki").children;
    for (let j = 0; j < tegakis.length; j++) {
      const score = tegakis[j].shadowRoot.querySelector("#score").textContent;
      scores.push(parseInt(score));
    }
  }
  let score = 0;
  for (let i = 0; i < scores.length; i++) {
    score += scores[i];
  }
  score /= scores.length;
  if (score >= 80) {
    playAudio(correctAllAudio);
    let clearedKanjis = localStorage.getItem("touch-shuji");
    if (clearedKanjis) {
      kanjis.split("").forEach((kanji) => {
        if (!clearedKanjis.includes(kanji)) {
          clearedKanjis += kanji;
        }
      });
      localStorage.setItem("touch-shuji", clearedKanjis);
    } else {
      localStorage.setItem("touch-shuji", kanjis);
    }
    document.getElementById("report").classList.add("d-none");
    document.getElementById("correctReport").classList.remove("d-none");
    setTimeout(() => {
      location.href = "/touch-shuji/";
    }, 3000);
  } else {
    playAudio(stupidAudio);
    document.getElementById("report").classList.add("d-none");
    document.getElementById("incorrectReport").classList.remove("d-none");
    setTimeout(function () {
      document.getElementById("report").classList.remove("d-none");
      document.getElementById("incorrectReport").classList.add("d-none");
    }, 6000);
  }
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const r = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[r];
    array[r] = tmp;
  }
  return array;
}

function parseQuery(queryString) {
  const query = {};
  const pairs = (queryString[0] === "?" ? queryString.substr(1) : queryString)
    .split("&");
  for (let i = 0; i < pairs.length; i++) {
    const pair = pairs[i].split("=");
    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || "");
  }
  return query;
}

function uniq(array) {
  return array.filter((elem, index, self) => self.indexOf(elem) === index);
}

function fetchJson(grade) {
  return new Promise((resolve) => {
    fetch(`/touch-shuji/data/${grade}.json`)
      .then((response) => response.json())
      .then((data) => resolve(data));
  });
}

async function fetchJsons(grades) {
  const data = new Array(10);
  for (let i = 0; i < grades.length; i++) {
    await fetchJson(grades[i]).then((result) => {
      data[grades[i]] = result;
    });
  }
  return data;
}

function initQuery() {
  const num = 5;
  const queries = parseQuery(location.search);
  kanjis = queries["q"] || "学";
  const targetKanjis = [];
  const targetGrades = [];
  const grades = new Array(10);
  for (let i = 0; i < kanjis.length; i++) {
    const g = getGrade(kanjis[i]);
    if (g > 0) {
      targetKanjis.push(kanjis[i]);
      targetGrades.push(g);
      grades[g] = true;
    }
  }
  fetchJsons(uniq(targetGrades)).then((data) => {
    let problems = [];
    if (targetKanjis.length == 1) {
      const kanji = targetKanjis[0];
      const grade = targetGrades[0];
      problems = [data[grade][kanji].shift()];
      problems = problems.concat(shuffle(data[grade][kanji]).slice(0, num));
    } else {
      targetKanjis.forEach((kanji, i) => {
        const grade = targetGrades[i];
        const candidates = data[grade][kanji].slice(1);
        problems = problems.concat(shuffle(candidates)[0]);
      });
    }
    loadDrill(problems);
    document.getElementById("problems").children[0].shadowRoot.querySelector(
      "#guard",
    ).style.height = "0";
  });
}
// https://qiita.com/noraworld/items/2834f2e6f064e6f6d41a
// https://webinlet.com/2020/ios11以降でピンチインアウト拡大縮小禁止
// 手を置いた時の誤爆を防ぎつつスクロールは許可
function scrollEvent(e) {
  if (
    !["MAIN", "PROBLEM-BOX", "A", "BUTTON", "path"].includes(e.target.tagName)
  ) {
    e.preventDefault();
  }
}

initQuery();

document.getElementById("toggleDarkMode").onclick = toggleDarkMode;
document.getElementById("hint").onclick = toggleHint;
document.getElementById("toggleScroll").onclick = toggleScroll;
document.getElementById("reportButton").onclick = report;
document.addEventListener("click", unlockAudio, {
  once: true,
  useCapture: true,
});

// disable troublesome iOS features
// - double tap zoom
document.ondblclick = (e) => {
  e.preventDefault();
};
// - selection context menu
// TODO: need better solution
document.body.style.webkitUserSelect = "none";
